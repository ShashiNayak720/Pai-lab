from collections import deque

def water_jug_bfs(capA, capB, goal, target):
    visited = set()
    q = deque([(0, 0, [])])   # (jugA, jugB, path)

    while q:
        a, b, path = q.popleft()
        if (target == 'A' and a == goal) or (target == 'B' and b == goal):
            return path + [(a, b)]

        if (a, b) in visited:
            continue
        visited.add((a, b))

        next_states = [
            (capA, b),   # Fill A
            (a, capB),   # Fill B
            (0, b),      # Empty A
            (a, 0),      # Empty B
            (a - min(a, capB - b), b + min(a, capB - b)),  # A → B
            (a + min(b, capA - a), b - min(b, capA - a))   # B → A
        ]

        for na, nb in next_states:
            if (na, nb) not in visited:
                q.append((na, nb, path + [(a, b)]))

    return None
capA = int(input("Enter capacity of Jug A: "))
capB = int(input("Enter capacity of Jug B: "))
goal = int(input("Enter goal amount: "))
target = input("Target jug (A/B): ").upper()

result = water_jug_bfs(capA, capB, goal, target)

if result:
    print("\nBFS Solution Path:")
    for state in result:
        print(state)
else:
    print("No solution possible")
